{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-25T17:10:17.986741Z",
     "start_time": "2018-01-25T17:10:15.345237Z"
    }
   },
   "outputs": [],
   "source": [
    "%matplotlib notebook\n",
    "%load_ext autoreload\n",
    "%autoreload 2\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "from libwallerlab.operators import operators as ops\n",
    "from libwallerlab.opticsalgorithms.motiondeblur import blurkernel\n",
    "from libwallerlab.utilities.opticstools import Ft, iFt\n",
    "import numpy as np\n",
    "import math"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define Constants"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-25T17:52:40.111434Z",
     "start_time": "2018-01-25T17:52:39.786000Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Image size requires 1 x 3 images\n"
     ]
    },
    {
     "data": {
      "application/javascript": [
       "/* Put everything inside the global mpl namespace */\n",
       "window.mpl = {};\n",
       "\n",
       "\n",
       "mpl.get_websocket_type = function() {\n",
       "    if (typeof(WebSocket) !== 'undefined') {\n",
       "        return WebSocket;\n",
       "    } else if (typeof(MozWebSocket) !== 'undefined') {\n",
       "        return MozWebSocket;\n",
       "    } else {\n",
       "        alert('Your browser does not have WebSocket support.' +\n",
       "              'Please try Chrome, Safari or Firefox â‰¥ 6. ' +\n",
       "              'Firefox 4 and 5 are also supported but you ' +\n",
       "              'have to enable WebSockets in about:config.');\n",
       "    };\n",
       "}\n",
       "\n",
       "mpl.figure = function(figure_id, websocket, ondownload, parent_element) {\n",
       "    this.id = figure_id;\n",
       "\n",
       "    this.ws = websocket;\n",
       "\n",
       "    this.supports_binary = (this.ws.binaryType != undefined);\n",
       "\n",
       "    if (!this.supports_binary) {\n",
       "        var warnings = document.getElementById(\"mpl-warnings\");\n",
       "        if (warnings) {\n",
       "            warnings.style.display = 'block';\n",
       "            warnings.textContent = (\n",
       "                \"This browser does not support binary websocket messages. \" +\n",
       "                    \"Performance may be slow.\");\n",
       "        }\n",
       "    }\n",
       "\n",
       "    this.imageObj = new Image();\n",
       "\n",
       "    this.context = undefined;\n",
       "    this.message = undefined;\n",
       "    this.canvas = undefined;\n",
       "    this.rubberband_canvas = undefined;\n",
       "    this.rubberband_context = undefined;\n",
       "    this.format_dropdown = undefined;\n",
       "\n",
       "    this.image_mode = 'full';\n",
       "\n",
       "    this.root = $('<div/>');\n",
       "    this._root_extra_style(this.root)\n",
       "    this.root.attr('style', 'display: inline-block');\n",
       "\n",
       "    $(parent_element).append(this.root);\n",
       "\n",
       "    this._init_header(this);\n",
       "    this._init_canvas(this);\n",
       "    this._init_toolbar(this);\n",
       "\n",
       "    var fig = this;\n",
       "\n",
       "    this.waiting = false;\n",
       "\n",
       "    this.ws.onopen =  function () {\n",
       "            fig.send_message(\"supports_binary\", {value: fig.supports_binary});\n",
       "            fig.send_message(\"send_image_mode\", {});\n",
       "            if (mpl.ratio != 1) {\n",
       "                fig.send_message(\"set_dpi_ratio\", {'dpi_ratio': mpl.ratio});\n",
       "            }\n",
       "            fig.send_message(\"refresh\", {});\n",
       "        }\n",
       "\n",
       "    this.imageObj.onload = function() {\n",
       "            if (fig.image_mode == 'full') {\n",
       "                // Full images could contain transparency (where diff images\n",
       "                // almost always do), so we need to clear the canvas so that\n",
       "                // there is no ghosting.\n",
       "                fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);\n",
       "            }\n",
       "            fig.context.drawImage(fig.imageObj, 0, 0);\n",
       "        };\n",
       "\n",
       "    this.imageObj.onunload = function() {\n",
       "        fig.ws.close();\n",
       "    }\n",
       "\n",
       "    this.ws.onmessage = this._make_on_message_function(this);\n",
       "\n",
       "    this.ondownload = ondownload;\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._init_header = function() {\n",
       "    var titlebar = $(\n",
       "        '<div class=\"ui-dialog-titlebar ui-widget-header ui-corner-all ' +\n",
       "        'ui-helper-clearfix\"/>');\n",
       "    var titletext = $(\n",
       "        '<div class=\"ui-dialog-title\" style=\"width: 100%; ' +\n",
       "        'text-align: center; padding: 3px;\"/>');\n",
       "    titlebar.append(titletext)\n",
       "    this.root.append(titlebar);\n",
       "    this.header = titletext[0];\n",
       "}\n",
       "\n",
       "\n",
       "\n",
       "mpl.figure.prototype._canvas_extra_style = function(canvas_div) {\n",
       "\n",
       "}\n",
       "\n",
       "\n",
       "mpl.figure.prototype._root_extra_style = function(canvas_div) {\n",
       "\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._init_canvas = function() {\n",
       "    var fig = this;\n",
       "\n",
       "    var canvas_div = $('<div/>');\n",
       "\n",
       "    canvas_div.attr('style', 'position: relative; clear: both; outline: 0');\n",
       "\n",
       "    function canvas_keyboard_event(event) {\n",
       "        return fig.key_event(event, event['data']);\n",
       "    }\n",
       "\n",
       "    canvas_div.keydown('key_press', canvas_keyboard_event);\n",
       "    canvas_div.keyup('key_release', canvas_keyboard_event);\n",
       "    this.canvas_div = canvas_div\n",
       "    this._canvas_extra_style(canvas_div)\n",
       "    this.root.append(canvas_div);\n",
       "\n",
       "    var canvas = $('<canvas/>');\n",
       "    canvas.addClass('mpl-canvas');\n",
       "    canvas.attr('style', \"left: 0; top: 0; z-index: 0; outline: 0\")\n",
       "\n",
       "    this.canvas = canvas[0];\n",
       "    this.context = canvas[0].getContext(\"2d\");\n",
       "\n",
       "    var backingStore = this.context.backingStorePixelRatio ||\n",
       "\tthis.context.webkitBackingStorePixelRatio ||\n",
       "\tthis.context.mozBackingStorePixelRatio ||\n",
       "\tthis.context.msBackingStorePixelRatio ||\n",
       "\tthis.context.oBackingStorePixelRatio ||\n",
       "\tthis.context.backingStorePixelRatio || 1;\n",
       "\n",
       "    mpl.ratio = (window.devicePixelRatio || 1) / backingStore;\n",
       "\n",
       "    var rubberband = $('<canvas/>');\n",
       "    rubberband.attr('style', \"position: absolute; left: 0; top: 0; z-index: 1;\")\n",
       "\n",
       "    var pass_mouse_events = true;\n",
       "\n",
       "    canvas_div.resizable({\n",
       "        start: function(event, ui) {\n",
       "            pass_mouse_events = false;\n",
       "        },\n",
       "        resize: function(event, ui) {\n",
       "            fig.request_resize(ui.size.width, ui.size.height);\n",
       "        },\n",
       "        stop: function(event, ui) {\n",
       "            pass_mouse_events = true;\n",
       "            fig.request_resize(ui.size.width, ui.size.height);\n",
       "        },\n",
       "    });\n",
       "\n",
       "    function mouse_event_fn(event) {\n",
       "        if (pass_mouse_events)\n",
       "            return fig.mouse_event(event, event['data']);\n",
       "    }\n",
       "\n",
       "    rubberband.mousedown('button_press', mouse_event_fn);\n",
       "    rubberband.mouseup('button_release', mouse_event_fn);\n",
       "    // Throttle sequential mouse events to 1 every 20ms.\n",
       "    rubberband.mousemove('motion_notify', mouse_event_fn);\n",
       "\n",
       "    rubberband.mouseenter('figure_enter', mouse_event_fn);\n",
       "    rubberband.mouseleave('figure_leave', mouse_event_fn);\n",
       "\n",
       "    canvas_div.on(\"wheel\", function (event) {\n",
       "        event = event.originalEvent;\n",
       "        event['data'] = 'scroll'\n",
       "        if (event.deltaY < 0) {\n",
       "            event.step = 1;\n",
       "        } else {\n",
       "            event.step = -1;\n",
       "        }\n",
       "        mouse_event_fn(event);\n",
       "    });\n",
       "\n",
       "    canvas_div.append(canvas);\n",
       "    canvas_div.append(rubberband);\n",
       "\n",
       "    this.rubberband = rubberband;\n",
       "    this.rubberband_canvas = rubberband[0];\n",
       "    this.rubberband_context = rubberband[0].getContext(\"2d\");\n",
       "    this.rubberband_context.strokeStyle = \"#000000\";\n",
       "\n",
       "    this._resize_canvas = function(width, height) {\n",
       "        // Keep the size of the canvas, canvas container, and rubber band\n",
       "        // canvas in synch.\n",
       "        canvas_div.css('width', width)\n",
       "        canvas_div.css('height', height)\n",
       "\n",
       "        canvas.attr('width', width * mpl.ratio);\n",
       "        canvas.attr('height', height * mpl.ratio);\n",
       "        canvas.attr('style', 'width: ' + width + 'px; height: ' + height + 'px;');\n",
       "\n",
       "        rubberband.attr('width', width);\n",
       "        rubberband.attr('height', height);\n",
       "    }\n",
       "\n",
       "    // Set the figure to an initial 600x600px, this will subsequently be updated\n",
       "    // upon first draw.\n",
       "    this._resize_canvas(600, 600);\n",
       "\n",
       "    // Disable right mouse context menu.\n",
       "    $(this.rubberband_canvas).bind(\"contextmenu\",function(e){\n",
       "        return false;\n",
       "    });\n",
       "\n",
       "    function set_focus () {\n",
       "        canvas.focus();\n",
       "        canvas_div.focus();\n",
       "    }\n",
       "\n",
       "    window.setTimeout(set_focus, 100);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._init_toolbar = function() {\n",
       "    var fig = this;\n",
       "\n",
       "    var nav_element = $('<div/>')\n",
       "    nav_element.attr('style', 'width: 100%');\n",
       "    this.root.append(nav_element);\n",
       "\n",
       "    // Define a callback function for later on.\n",
       "    function toolbar_event(event) {\n",
       "        return fig.toolbar_button_onclick(event['data']);\n",
       "    }\n",
       "    function toolbar_mouse_event(event) {\n",
       "        return fig.toolbar_button_onmouseover(event['data']);\n",
       "    }\n",
       "\n",
       "    for(var toolbar_ind in mpl.toolbar_items) {\n",
       "        var name = mpl.toolbar_items[toolbar_ind][0];\n",
       "        var tooltip = mpl.toolbar_items[toolbar_ind][1];\n",
       "        var image = mpl.toolbar_items[toolbar_ind][2];\n",
       "        var method_name = mpl.toolbar_items[toolbar_ind][3];\n",
       "\n",
       "        if (!name) {\n",
       "            // put a spacer in here.\n",
       "            continue;\n",
       "        }\n",
       "        var button = $('<button/>');\n",
       "        button.addClass('ui-button ui-widget ui-state-default ui-corner-all ' +\n",
       "                        'ui-button-icon-only');\n",
       "        button.attr('role', 'button');\n",
       "        button.attr('aria-disabled', 'false');\n",
       "        button.click(method_name, toolbar_event);\n",
       "        button.mouseover(tooltip, toolbar_mouse_event);\n",
       "\n",
       "        var icon_img = $('<span/>');\n",
       "        icon_img.addClass('ui-button-icon-primary ui-icon');\n",
       "        icon_img.addClass(image);\n",
       "        icon_img.addClass('ui-corner-all');\n",
       "\n",
       "        var tooltip_span = $('<span/>');\n",
       "        tooltip_span.addClass('ui-button-text');\n",
       "        tooltip_span.html(tooltip);\n",
       "\n",
       "        button.append(icon_img);\n",
       "        button.append(tooltip_span);\n",
       "\n",
       "        nav_element.append(button);\n",
       "    }\n",
       "\n",
       "    var fmt_picker_span = $('<span/>');\n",
       "\n",
       "    var fmt_picker = $('<select/>');\n",
       "    fmt_picker.addClass('mpl-toolbar-option ui-widget ui-widget-content');\n",
       "    fmt_picker_span.append(fmt_picker);\n",
       "    nav_element.append(fmt_picker_span);\n",
       "    this.format_dropdown = fmt_picker[0];\n",
       "\n",
       "    for (var ind in mpl.extensions) {\n",
       "        var fmt = mpl.extensions[ind];\n",
       "        var option = $(\n",
       "            '<option/>', {selected: fmt === mpl.default_extension}).html(fmt);\n",
       "        fmt_picker.append(option)\n",
       "    }\n",
       "\n",
       "    // Add hover states to the ui-buttons\n",
       "    $( \".ui-button\" ).hover(\n",
       "        function() { $(this).addClass(\"ui-state-hover\");},\n",
       "        function() { $(this).removeClass(\"ui-state-hover\");}\n",
       "    );\n",
       "\n",
       "    var status_bar = $('<span class=\"mpl-message\"/>');\n",
       "    nav_element.append(status_bar);\n",
       "    this.message = status_bar[0];\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.request_resize = function(x_pixels, y_pixels) {\n",
       "    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,\n",
       "    // which will in turn request a refresh of the image.\n",
       "    this.send_message('resize', {'width': x_pixels, 'height': y_pixels});\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.send_message = function(type, properties) {\n",
       "    properties['type'] = type;\n",
       "    properties['figure_id'] = this.id;\n",
       "    this.ws.send(JSON.stringify(properties));\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.send_draw_message = function() {\n",
       "    if (!this.waiting) {\n",
       "        this.waiting = true;\n",
       "        this.ws.send(JSON.stringify({type: \"draw\", figure_id: this.id}));\n",
       "    }\n",
       "}\n",
       "\n",
       "\n",
       "mpl.figure.prototype.handle_save = function(fig, msg) {\n",
       "    var format_dropdown = fig.format_dropdown;\n",
       "    var format = format_dropdown.options[format_dropdown.selectedIndex].value;\n",
       "    fig.ondownload(fig, format);\n",
       "}\n",
       "\n",
       "\n",
       "mpl.figure.prototype.handle_resize = function(fig, msg) {\n",
       "    var size = msg['size'];\n",
       "    if (size[0] != fig.canvas.width || size[1] != fig.canvas.height) {\n",
       "        fig._resize_canvas(size[0], size[1]);\n",
       "        fig.send_message(\"refresh\", {});\n",
       "    };\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_rubberband = function(fig, msg) {\n",
       "    var x0 = msg['x0'] / mpl.ratio;\n",
       "    var y0 = (fig.canvas.height - msg['y0']) / mpl.ratio;\n",
       "    var x1 = msg['x1'] / mpl.ratio;\n",
       "    var y1 = (fig.canvas.height - msg['y1']) / mpl.ratio;\n",
       "    x0 = Math.floor(x0) + 0.5;\n",
       "    y0 = Math.floor(y0) + 0.5;\n",
       "    x1 = Math.floor(x1) + 0.5;\n",
       "    y1 = Math.floor(y1) + 0.5;\n",
       "    var min_x = Math.min(x0, x1);\n",
       "    var min_y = Math.min(y0, y1);\n",
       "    var width = Math.abs(x1 - x0);\n",
       "    var height = Math.abs(y1 - y0);\n",
       "\n",
       "    fig.rubberband_context.clearRect(\n",
       "        0, 0, fig.canvas.width, fig.canvas.height);\n",
       "\n",
       "    fig.rubberband_context.strokeRect(min_x, min_y, width, height);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_figure_label = function(fig, msg) {\n",
       "    // Updates the figure title.\n",
       "    fig.header.textContent = msg['label'];\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_cursor = function(fig, msg) {\n",
       "    var cursor = msg['cursor'];\n",
       "    switch(cursor)\n",
       "    {\n",
       "    case 0:\n",
       "        cursor = 'pointer';\n",
       "        break;\n",
       "    case 1:\n",
       "        cursor = 'default';\n",
       "        break;\n",
       "    case 2:\n",
       "        cursor = 'crosshair';\n",
       "        break;\n",
       "    case 3:\n",
       "        cursor = 'move';\n",
       "        break;\n",
       "    }\n",
       "    fig.rubberband_canvas.style.cursor = cursor;\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_message = function(fig, msg) {\n",
       "    fig.message.textContent = msg['message'];\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_draw = function(fig, msg) {\n",
       "    // Request the server to send over a new figure.\n",
       "    fig.send_draw_message();\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_image_mode = function(fig, msg) {\n",
       "    fig.image_mode = msg['mode'];\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.updated_canvas_event = function() {\n",
       "    // Called whenever the canvas gets updated.\n",
       "    this.send_message(\"ack\", {});\n",
       "}\n",
       "\n",
       "// A function to construct a web socket function for onmessage handling.\n",
       "// Called in the figure constructor.\n",
       "mpl.figure.prototype._make_on_message_function = function(fig) {\n",
       "    return function socket_on_message(evt) {\n",
       "        if (evt.data instanceof Blob) {\n",
       "            /* FIXME: We get \"Resource interpreted as Image but\n",
       "             * transferred with MIME type text/plain:\" errors on\n",
       "             * Chrome.  But how to set the MIME type?  It doesn't seem\n",
       "             * to be part of the websocket stream */\n",
       "            evt.data.type = \"image/png\";\n",
       "\n",
       "            /* Free the memory for the previous frames */\n",
       "            if (fig.imageObj.src) {\n",
       "                (window.URL || window.webkitURL).revokeObjectURL(\n",
       "                    fig.imageObj.src);\n",
       "            }\n",
       "\n",
       "            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(\n",
       "                evt.data);\n",
       "            fig.updated_canvas_event();\n",
       "            fig.waiting = false;\n",
       "            return;\n",
       "        }\n",
       "        else if (typeof evt.data === 'string' && evt.data.slice(0, 21) == \"data:image/png;base64\") {\n",
       "            fig.imageObj.src = evt.data;\n",
       "            fig.updated_canvas_event();\n",
       "            fig.waiting = false;\n",
       "            return;\n",
       "        }\n",
       "\n",
       "        var msg = JSON.parse(evt.data);\n",
       "        var msg_type = msg['type'];\n",
       "\n",
       "        // Call the  \"handle_{type}\" callback, which takes\n",
       "        // the figure and JSON message as its only arguments.\n",
       "        try {\n",
       "            var callback = fig[\"handle_\" + msg_type];\n",
       "        } catch (e) {\n",
       "            console.log(\"No handler for the '\" + msg_type + \"' message type: \", msg);\n",
       "            return;\n",
       "        }\n",
       "\n",
       "        if (callback) {\n",
       "            try {\n",
       "                // console.log(\"Handling '\" + msg_type + \"' message: \", msg);\n",
       "                callback(fig, msg);\n",
       "            } catch (e) {\n",
       "                console.log(\"Exception inside the 'handler_\" + msg_type + \"' callback:\", e, e.stack, msg);\n",
       "            }\n",
       "        }\n",
       "    };\n",
       "}\n",
       "\n",
       "// from http://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas\n",
       "mpl.findpos = function(e) {\n",
       "    //this section is from http://www.quirksmode.org/js/events_properties.html\n",
       "    var targ;\n",
       "    if (!e)\n",
       "        e = window.event;\n",
       "    if (e.target)\n",
       "        targ = e.target;\n",
       "    else if (e.srcElement)\n",
       "        targ = e.srcElement;\n",
       "    if (targ.nodeType == 3) // defeat Safari bug\n",
       "        targ = targ.parentNode;\n",
       "\n",
       "    // jQuery normalizes the pageX and pageY\n",
       "    // pageX,Y are the mouse positions relative to the document\n",
       "    // offset() returns the position of the element relative to the document\n",
       "    var x = e.pageX - $(targ).offset().left;\n",
       "    var y = e.pageY - $(targ).offset().top;\n",
       "\n",
       "    return {\"x\": x, \"y\": y};\n",
       "};\n",
       "\n",
       "/*\n",
       " * return a copy of an object with only non-object keys\n",
       " * we need this to avoid circular references\n",
       " * http://stackoverflow.com/a/24161582/3208463\n",
       " */\n",
       "function simpleKeys (original) {\n",
       "  return Object.keys(original).reduce(function (obj, key) {\n",
       "    if (typeof original[key] !== 'object')\n",
       "        obj[key] = original[key]\n",
       "    return obj;\n",
       "  }, {});\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.mouse_event = function(event, name) {\n",
       "    var canvas_pos = mpl.findpos(event)\n",
       "\n",
       "    if (name === 'button_press')\n",
       "    {\n",
       "        this.canvas.focus();\n",
       "        this.canvas_div.focus();\n",
       "    }\n",
       "\n",
       "    var x = canvas_pos.x * mpl.ratio;\n",
       "    var y = canvas_pos.y * mpl.ratio;\n",
       "\n",
       "    this.send_message(name, {x: x, y: y, button: event.button,\n",
       "                             step: event.step,\n",
       "                             guiEvent: simpleKeys(event)});\n",
       "\n",
       "    /* This prevents the web browser from automatically changing to\n",
       "     * the text insertion cursor when the button is pressed.  We want\n",
       "     * to control all of the cursor setting manually through the\n",
       "     * 'cursor' event from matplotlib */\n",
       "    event.preventDefault();\n",
       "    return false;\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._key_event_extra = function(event, name) {\n",
       "    // Handle any extra behaviour associated with a key event\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.key_event = function(event, name) {\n",
       "\n",
       "    // Prevent repeat events\n",
       "    if (name == 'key_press')\n",
       "    {\n",
       "        if (event.which === this._key)\n",
       "            return;\n",
       "        else\n",
       "            this._key = event.which;\n",
       "    }\n",
       "    if (name == 'key_release')\n",
       "        this._key = null;\n",
       "\n",
       "    var value = '';\n",
       "    if (event.ctrlKey && event.which != 17)\n",
       "        value += \"ctrl+\";\n",
       "    if (event.altKey && event.which != 18)\n",
       "        value += \"alt+\";\n",
       "    if (event.shiftKey && event.which != 16)\n",
       "        value += \"shift+\";\n",
       "\n",
       "    value += 'k';\n",
       "    value += event.which.toString();\n",
       "\n",
       "    this._key_event_extra(event, name);\n",
       "\n",
       "    this.send_message(name, {key: value,\n",
       "                             guiEvent: simpleKeys(event)});\n",
       "    return false;\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.toolbar_button_onclick = function(name) {\n",
       "    if (name == 'download') {\n",
       "        this.handle_save(this, null);\n",
       "    } else {\n",
       "        this.send_message(\"toolbar_button\", {name: name});\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.toolbar_button_onmouseover = function(tooltip) {\n",
       "    this.message.textContent = tooltip;\n",
       "};\n",
       "mpl.toolbar_items = [[\"Home\", \"Reset original view\", \"fa fa-home icon-home\", \"home\"], [\"Back\", \"Back to  previous view\", \"fa fa-arrow-left icon-arrow-left\", \"back\"], [\"Forward\", \"Forward to next view\", \"fa fa-arrow-right icon-arrow-right\", \"forward\"], [\"\", \"\", \"\", \"\"], [\"Pan\", \"Pan axes with left mouse, zoom with right\", \"fa fa-arrows icon-move\", \"pan\"], [\"Zoom\", \"Zoom to rectangle\", \"fa fa-square-o icon-check-empty\", \"zoom\"], [\"\", \"\", \"\", \"\"], [\"Download\", \"Download plot\", \"fa fa-floppy-o icon-save\", \"download\"]];\n",
       "\n",
       "mpl.extensions = [\"eps\", \"jpeg\", \"pdf\", \"png\", \"ps\", \"raw\", \"svg\", \"tif\"];\n",
       "\n",
       "mpl.default_extension = \"png\";var comm_websocket_adapter = function(comm) {\n",
       "    // Create a \"websocket\"-like object which calls the given IPython comm\n",
       "    // object with the appropriate methods. Currently this is a non binary\n",
       "    // socket, so there is still some room for performance tuning.\n",
       "    var ws = {};\n",
       "\n",
       "    ws.close = function() {\n",
       "        comm.close()\n",
       "    };\n",
       "    ws.send = function(m) {\n",
       "        //console.log('sending', m);\n",
       "        comm.send(m);\n",
       "    };\n",
       "    // Register the callback with on_msg.\n",
       "    comm.on_msg(function(msg) {\n",
       "        //console.log('receiving', msg['content']['data'], msg);\n",
       "        // Pass the mpl event to the overriden (by mpl) onmessage function.\n",
       "        ws.onmessage(msg['content']['data'])\n",
       "    });\n",
       "    return ws;\n",
       "}\n",
       "\n",
       "mpl.mpl_figure_comm = function(comm, msg) {\n",
       "    // This is the function which gets called when the mpl process\n",
       "    // starts-up an IPython Comm through the \"matplotlib\" channel.\n",
       "\n",
       "    var id = msg.content.data.id;\n",
       "    // Get hold of the div created by the display call when the Comm\n",
       "    // socket was opened in Python.\n",
       "    var element = $(\"#\" + id);\n",
       "    var ws_proxy = comm_websocket_adapter(comm)\n",
       "\n",
       "    function ondownload(figure, format) {\n",
       "        window.open(figure.imageObj.src);\n",
       "    }\n",
       "\n",
       "    var fig = new mpl.figure(id, ws_proxy,\n",
       "                           ondownload,\n",
       "                           element.get(0));\n",
       "\n",
       "    // Call onopen now - mpl needs it, as it is assuming we've passed it a real\n",
       "    // web socket which is closed, not our websocket->open comm proxy.\n",
       "    ws_proxy.onopen();\n",
       "\n",
       "    fig.parent_element = element.get(0);\n",
       "    fig.cell_info = mpl.find_output_cell(\"<div id='\" + id + \"'></div>\");\n",
       "    if (!fig.cell_info) {\n",
       "        console.error(\"Failed to find cell for figure\", id, fig);\n",
       "        return;\n",
       "    }\n",
       "\n",
       "    var output_index = fig.cell_info[2]\n",
       "    var cell = fig.cell_info[0];\n",
       "\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_close = function(fig, msg) {\n",
       "    var width = fig.canvas.width/mpl.ratio\n",
       "    fig.root.unbind('remove')\n",
       "\n",
       "    // Update the output cell to use the data from the current canvas.\n",
       "    fig.push_to_output();\n",
       "    var dataURL = fig.canvas.toDataURL();\n",
       "    // Re-enable the keyboard manager in IPython - without this line, in FF,\n",
       "    // the notebook keyboard shortcuts fail.\n",
       "    IPython.keyboard_manager.enable()\n",
       "    $(fig.parent_element).html('<img src=\"' + dataURL + '\" width=\"' + width + '\">');\n",
       "    fig.close_ws(fig, msg);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.close_ws = function(fig, msg){\n",
       "    fig.send_message('closing', msg);\n",
       "    // fig.ws.close()\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.push_to_output = function(remove_interactive) {\n",
       "    // Turn the data on the canvas into data in the output cell.\n",
       "    var width = this.canvas.width/mpl.ratio\n",
       "    var dataURL = this.canvas.toDataURL();\n",
       "    this.cell_info[1]['text/html'] = '<img src=\"' + dataURL + '\" width=\"' + width + '\">';\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.updated_canvas_event = function() {\n",
       "    // Tell IPython that the notebook contents must change.\n",
       "    IPython.notebook.set_dirty(true);\n",
       "    this.send_message(\"ack\", {});\n",
       "    var fig = this;\n",
       "    // Wait a second, then push the new image to the DOM so\n",
       "    // that it is saved nicely (might be nice to debounce this).\n",
       "    setTimeout(function () { fig.push_to_output() }, 1000);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._init_toolbar = function() {\n",
       "    var fig = this;\n",
       "\n",
       "    var nav_element = $('<div/>')\n",
       "    nav_element.attr('style', 'width: 100%');\n",
       "    this.root.append(nav_element);\n",
       "\n",
       "    // Define a callback function for later on.\n",
       "    function toolbar_event(event) {\n",
       "        return fig.toolbar_button_onclick(event['data']);\n",
       "    }\n",
       "    function toolbar_mouse_event(event) {\n",
       "        return fig.toolbar_button_onmouseover(event['data']);\n",
       "    }\n",
       "\n",
       "    for(var toolbar_ind in mpl.toolbar_items){\n",
       "        var name = mpl.toolbar_items[toolbar_ind][0];\n",
       "        var tooltip = mpl.toolbar_items[toolbar_ind][1];\n",
       "        var image = mpl.toolbar_items[toolbar_ind][2];\n",
       "        var method_name = mpl.toolbar_items[toolbar_ind][3];\n",
       "\n",
       "        if (!name) { continue; };\n",
       "\n",
       "        var button = $('<button class=\"btn btn-default\" href=\"#\" title=\"' + name + '\"><i class=\"fa ' + image + ' fa-lg\"></i></button>');\n",
       "        button.click(method_name, toolbar_event);\n",
       "        button.mouseover(tooltip, toolbar_mouse_event);\n",
       "        nav_element.append(button);\n",
       "    }\n",
       "\n",
       "    // Add the status bar.\n",
       "    var status_bar = $('<span class=\"mpl-message\" style=\"text-align:right; float: right;\"/>');\n",
       "    nav_element.append(status_bar);\n",
       "    this.message = status_bar[0];\n",
       "\n",
       "    // Add the close button to the window.\n",
       "    var buttongrp = $('<div class=\"btn-group inline pull-right\"></div>');\n",
       "    var button = $('<button class=\"btn btn-mini btn-primary\" href=\"#\" title=\"Stop Interaction\"><i class=\"fa fa-power-off icon-remove icon-large\"></i></button>');\n",
       "    button.click(function (evt) { fig.handle_close(fig, {}); } );\n",
       "    button.mouseover('Stop Interaction', toolbar_mouse_event);\n",
       "    buttongrp.append(button);\n",
       "    var titlebar = this.root.find($('.ui-dialog-titlebar'));\n",
       "    titlebar.prepend(buttongrp);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._root_extra_style = function(el){\n",
       "    var fig = this\n",
       "    el.on(\"remove\", function(){\n",
       "\tfig.close_ws(fig, {});\n",
       "    });\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._canvas_extra_style = function(el){\n",
       "    // this is important to make the div 'focusable\n",
       "    el.attr('tabindex', 0)\n",
       "    // reach out to IPython and tell the keyboard manager to turn it's self\n",
       "    // off when our div gets focus\n",
       "\n",
       "    // location in version 3\n",
       "    if (IPython.notebook.keyboard_manager) {\n",
       "        IPython.notebook.keyboard_manager.register_events(el);\n",
       "    }\n",
       "    else {\n",
       "        // location in version 2\n",
       "        IPython.keyboard_manager.register_events(el);\n",
       "    }\n",
       "\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._key_event_extra = function(event, name) {\n",
       "    var manager = IPython.notebook.keyboard_manager;\n",
       "    if (!manager)\n",
       "        manager = IPython.keyboard_manager;\n",
       "\n",
       "    // Check for shift+enter\n",
       "    if (event.shiftKey && event.which == 13) {\n",
       "        this.canvas_div.blur();\n",
       "        event.shiftKey = false;\n",
       "        // Send a \"J\" for go to next cell\n",
       "        event.which = 74;\n",
       "        event.keyCode = 74;\n",
       "        manager.command_mode();\n",
       "        manager.handle_keydown(event);\n",
       "    }\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_save = function(fig, msg) {\n",
       "    fig.ondownload(fig, null);\n",
       "}\n",
       "\n",
       "\n",
       "mpl.find_output_cell = function(html_output) {\n",
       "    // Return the cell and output element which can be found *uniquely* in the notebook.\n",
       "    // Note - this is a bit hacky, but it is done because the \"notebook_saving.Notebook\"\n",
       "    // IPython event is triggered only after the cells have been serialised, which for\n",
       "    // our purposes (turning an active figure into a static one), is too late.\n",
       "    var cells = IPython.notebook.get_cells();\n",
       "    var ncells = cells.length;\n",
       "    for (var i=0; i<ncells; i++) {\n",
       "        var cell = cells[i];\n",
       "        if (cell.cell_type === 'code'){\n",
       "            for (var j=0; j<cell.output_area.outputs.length; j++) {\n",
       "                var data = cell.output_area.outputs[j];\n",
       "                if (data.data) {\n",
       "                    // IPython >= 3 moved mimebundle to data attribute of output\n",
       "                    data = data.data;\n",
       "                }\n",
       "                if (data['text/html'] == html_output) {\n",
       "                    return [cell, data, j];\n",
       "                }\n",
       "            }\n",
       "        }\n",
       "    }\n",
       "}\n",
       "\n",
       "// Register the function which deals with the matplotlib target/channel.\n",
       "// The kernel may be null if the page has been refreshed.\n",
       "if (IPython.notebook.kernel != null) {\n",
       "    IPython.notebook.kernel.comm_manager.register_target('matplotlib', mpl.mpl_figure_comm);\n",
       "}\n"
      ],
      "text/plain": [
       "<IPython.core.display.Javascript object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLAAAAGQCAYAAAC+tZleAAAAAXNSR0IArs4c6QAAQABJREFUeAHsvQmcbVdd57vPqVPDHcNNIDEktIgiw1NARcUkgBlubghBkSE8BoV2RFRstUV90dfhPdCm8dkOjeIAgihKUMROvBluQqIZjBrFblsNjTIlQBKS3CR3qrne7/ffe+1adWo6VbdO1Tmnvutzd62111577bW++9z/f63/GnZR4CAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAE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g9gb5X2zGZu/zwPeT2yuzMTyZzLh/HjKy/8Lryb/q5S9lv6rjyq+p7HNT9LHJ1L3ZqNMtqOAGNkRSjMCIwqIjyOCLWBz8XEBL4pDWhoBMXJpLuVKn0i5UVlpBCc/eYGs1rgtN73V87A+2tL7hbR5eGNj45ctbVQRINAQyJuP6osSPtAoGimbMXciY+5z/TbKuH0k9d9P3S396ntlJ/NtUY9YfdUi1KFKjOyApAmBEQXExxHBFrS5+LigF8ZhbXkBMXLLX0InEAETWP4ZTFUgb0IerCap8ntvVmvsy86qFVfP5venuQk+npvgC1M9AJ0TWDKBvPl4Pae0a9zTylgcOIFV9ZnnX91x7dq1Lyb7QNremXRX0herlVv5qOEPTDhXSpP7ESMnZ6knAuLjcv0bEB+X63o6m/kLiJHzvwaOgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBVU6VnAAABoElEQVRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMCSCfwXU5wTdKn+G6cAAAAASUVORK5CYII=\" width=\"600\">"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "image_size = (8, 8)\n",
    "object_size = (8, 8*3)\n",
    "\n",
    "# Generate motion pathway\n",
    "point_list_full = blurkernel.genRasterMotionPathway(object_size, image_size, \n",
    "                                                         full_object_multi_pass=False)\n",
    "\n",
    "# Generate blur kernel list\n",
    "blur_kernel_list = []\n",
    "for point_list_frame in point_list_full:\n",
    "    blur_kernel_list.append(blurkernel.pointListToBlurKernel(object_size, point_list_frame, np.random.rand(len(point_list_frame))))\n",
    "\n",
    "# Show blur kernels\n",
    "blurkernel.plotBlurKernelList(blur_kernel_list, figsize=(6,2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Condition Number of Vertically Stacked Diagonal Matricies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-25T17:46:55.239705Z",
     "start_time": "2018-01-25T17:46:54.648169Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "K_D1: 10.38624382\n",
      "K_D2: 4.93242788\n",
      "K_[D1; D2] (ACTUAL): 3.79907155\n"
     ]
    },
    {
     "ename": "AssertionError",
     "evalue": "Found difference of 0.00000024",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mAssertionError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-15-4d3490c62452>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     17\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'K_[D1; D2] (ACTUAL): %.8f'\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mk_v\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     18\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 19\u001b[0;31m \u001b[0;32massert\u001b[0m \u001b[0mk_v\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0mk_c\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"Found difference of %.8f\"\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mabs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mk_v\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0mk_c\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;31mAssertionError\u001b[0m: Found difference of 0.00000024"
     ]
    }
   ],
   "source": [
    "# Generate two random, complex matricies and stack vertically\n",
    "D1 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]))\n",
    "D2 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]))\n",
    "V = ops.Vstack((D1, D2)) # Vertically stack\n",
    "\n",
    "# Compute individual condition numbers of each matrix\n",
    "k_D1 = np.linalg.cond(D1.asFullMatrix())\n",
    "k_D2 = np.linalg.cond(D2.asFullMatrix())\n",
    "k_v = np.linalg.cond(V.asFullMatrix())\n",
    "\n",
    "# Estimate condition number using elements of D1 and D2 only\n",
    "c = np.sqrt(np.abs(D1.mult) ** 2 + np.abs(D2.mult) ** 2)\n",
    "k_c = np.amax(c) / np.amin(c)\n",
    "\n",
    "print('K_D1: %.8f' % k_D1)\n",
    "print('K_D2: %.8f' % k_D2)\n",
    "print('K_[D1; D2] (ACTUAL): %.8f' % k_v)\n",
    "\n",
    "assert k_v == k_c, \"Found difference of %.8f\" % abs(k_v - k_c)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Diagonally Stacked Diagonal Matricies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-25T17:47:00.218482Z",
     "start_time": "2018-01-25T17:47:00.114365Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "K_d1: 15.38733673\n",
      "K_d2: 5.965101\n",
      "K_[d1,0; 0, d2]: 15.38733673\n",
      "K_c: 15.38733673\n"
     ]
    }
   ],
   "source": [
    "D1 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]))\n",
    "D2 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]))\n",
    "D = ops.DiagStack((D1, D2))\n",
    "\n",
    "# Calculate condition numbers\n",
    "k_d1 = np.linalg.cond(D1.asFullMatrix())\n",
    "k_d2 = np.linalg.cond(D2.asFullMatrix())\n",
    "k_d = np.linalg.cond(D.asFullMatrix())\n",
    "\n",
    "# Concatenate kernels together directly and take absolute value\n",
    "c = np.vstack((D1.mult.reshape(-1), D2.mult.reshape(-1)))\n",
    "k_c = np.amax(np.abs(c)) / np.min(np.abs(c))\n",
    "\n",
    "print('K_d1: %.8f' % k_d1)\n",
    "print('K_d2: %.6f' % k_d2)\n",
    "print('K_[d1,0; 0, d2]: %.8f' % k_d)\n",
    "print('K_c: %.8f' % k_c)\n",
    "assert k_c == k_d"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The above two cells indicate we know how to calculate the condition number of diagonally or vertically stacked diagonal matricies (more or less - discrepancies probably due to floating point error). We now explore if we can estimate the condition number of a product of a diagonal matrix and a vertical matrix, that is:\n",
    "\n",
    "$$\\kappa \\{ \\begin{bmatrix} D_1 & 0 \\cr 0 & D_2 \\end{bmatrix} \\begin{bmatrix} D_3 \\cr  D_4 \\end{bmatrix} \\} = ?$$\n",
    "\n",
    "Where all $D_i$ are diagonal, complex matricies $\\forall i\\in[1,2,3,4]$. In our problem, this can be represented as:\n",
    "\n",
    "$$\\kappa \\{ \\begin{bmatrix} W^T W S_1 & 0 \\cr 0 & W^T W S_2 \\end{bmatrix} \\begin{bmatrix} F^H & 0 \\cr 0 & F^H \\end{bmatrix}\\begin{bmatrix} diag(\\tilde{b}_1) \\cr  diag(\\tilde{b}_2) \\end{bmatrix} \\} = ?$$\n",
    "\n",
    "In the following example, we focus only on the first case as an example."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-23T21:17:53.691296Z",
     "start_time": "2018-01-23T21:17:53.214360Z"
    }
   },
   "outputs": [],
   "source": [
    "D1 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "D2 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "D_diag = ops.DiagStack((D1, D2))\n",
    "\n",
    "D3 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "D4 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "D_vert = ops.Vstack((D3, D4))\n",
    "\n",
    "A = D_diag * D_vert\n",
    "\n",
    "# Calculate condition numbers\n",
    "k_D_diag = np.linalg.cond(D_diag.asFullMatrix())\n",
    "k_D_vert = np.linalg.cond(D_vert.asFullMatrix())\n",
    "k_A = np.linalg.cond(A.asFullMatrix())\n",
    "\n",
    "# Analytic calculation of condition numbers:\n",
    "c = np.sqrt(np.abs(D1.mult * D3.mult) ** 2 + np.abs(D2.mult * D4.mult) ** 2)\n",
    "k_c = np.amax(c) / np.amin(c)\n",
    "\n",
    "print('k_D_diag: %.8f' % k_D_diag)\n",
    "print('k_D_vert: %.8f' % k_D_vert)\n",
    "print('k_A: %.8f' % k_A)\n",
    "print('k_c: %.8f' % k_c)\n",
    "assert np.abs(k_A - k_c) < 1e-10, \"Found difference of %.12f\" % abs(k_A - k_c)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's see if this works the same when we combine a DFT matrix. Since the resulting matricies are no longer diagonal,the analysis is a bit different. It can clearly be seen that these matricies collapse to a vertically stacked matrix:\n",
    "\n",
    "$$\\begin{bmatrix} D_1 & 0 \\cr 0 & D_2 \\end{bmatrix} \\begin{bmatrix} F^H & 0 \\cr 0 & F^H \\end{bmatrix}\\begin{bmatrix} D_3 \\cr  D_3 \\end{bmatrix} = \\begin{bmatrix} D_1 F^H D_3 \\cr  D_2 F^H D_4 \\end{bmatrix}$$\n",
    "\n",
    "First, we need to be able to evaluate (or estimate) the condition number of an individual block,\n",
    "\n",
    "$$\\kappa \\{D_1 F^H D_2\\} = ?$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-23T21:18:05.567138Z",
     "start_time": "2018-01-23T21:18:05.336528Z"
    }
   },
   "outputs": [],
   "source": [
    "D1 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "D2 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "F = ops.FourierTransform(image_size, dtype=np.complex128)\n",
    "\n",
    "A = D1 * F.H * D2\n",
    "\n",
    "k_D1 = np.linalg.cond((D1).asFullMatrix())\n",
    "k_FD2 = np.linalg.cond((F.H * D2).asFullMatrix())\n",
    "k_A = np.linalg.cond(A.asFullMatrix())\n",
    "\n",
    "print('k_D1: %.8f' % k_D1)\n",
    "print('k_FD2: %.8f' % k_FD2)\n",
    "print('k_A: %.8f' % k_A)\n",
    "\n",
    "assert k_A < (k_D1 * k_FD2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The SVD of the above matrix would look like this:\n",
    "\n",
    "$$eig\\{D_2^* F D_1^* D_1 F^H D_2\\} $$\n",
    "Making the outer eigenvalues unitary is not really possible since $F$ is dense. So, we'll have to settle for the upper bound:\n",
    "\n",
    "$$ \\kappa \\{D_1 F^H D_2\\} \\geq \\kappa \\{D_1\\} \\kappa \\{D_2\\}$$\n",
    "\n",
    "Note we have omitted $F$ since it is unitary. In the vertically stacked case, we now want to see if this upper bound still holds true. To evaluate this, we take the SVD of the vertically stacked matrix:\n",
    "\n",
    "$$eig\\{ \\begin{bmatrix} D_3^* F D_1^* &  D_4^* F D_2 \\end{bmatrix}\\begin{bmatrix} D_1 F^H D_3 \\cr  D_2 F^H D_4 \\end{bmatrix}\\} = eig\\{ D_3^* F D_1^*  D_1 F^H D_3 +  D_4^* F D_2 D_2 F^H D_4\\}$$\n",
    "\n",
    "Before, when we knew the eigenvalues, we were able to evaluate the condition number of a vertically stacked matrix:\n",
    "\n",
    "$$\\kappa = \\frac{\\max \\{\\sqrt{|\\lambda_1|^2 + |\\lambda_2|^2} \\}}{\\min \\{\\sqrt{|\\lambda_1|^2 + |\\lambda_2|^2} \\}}$$\n",
    "\n",
    "We can use the condition number of each individual sub-matrix to bound $|\\lambda_i|$, assuming we know $|\\lambda_{max}| = \\beta$ is constant for all measurements:\n",
    "$$\\kappa = \\frac{|\\lambda_{max}|}{|\\lambda_{min}|} = \\frac{\\beta}{|\\lambda_{min}|}$$\n",
    "\n",
    "$$ |\\lambda_{min}| = \\frac{\\beta}{\\kappa} $$\n",
    "\n",
    "This reveals a new condition number which is dependent on the condition numbers of each block matrix $\\kappa_i$ and $\\beta$:\n",
    "\n",
    "$$\\kappa = \\frac{ \\sqrt{2\\beta^2}}{\\sqrt{(\\frac{\\beta}{\\kappa_1})^2 + \\frac{\\beta}{\\kappa_2})^2}}$$\n",
    "\n",
    "However, $\\kappa_i$ are all upper bounds, so this now also becomes an upper bound, since the largest $\\kappa_i$ will lead to the largest overall $\\kappa$:\n",
    "\n",
    "$$\\kappa \\leq \\frac{ \\sqrt{2\\beta^2}}{\\sqrt{(\\frac{\\beta}{\\kappa_1})^2 + \\frac{\\beta}{\\kappa_2})^2}}$$\n",
    "\n",
    "This analysis is only true if we can evaluate a meaningful $\\kappa_i$ for each measurement's forward model. Since these are not square, we need to use the singular-value definition. However, this bound would not consider individual coverage relative to other measurements, so it's not the best idea."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Considering Coverage\n",
    "Adding a window does two things - reduces the amount of data acquired, and imposes a convolution support on each measurement. We will call this support $M_i$, where:\n",
    "\n",
    "$$ M_i = B_i \\star W $$\n",
    "\n",
    "Here, the $\\star$ represents a cross-correlation. Adding this $M_i$ as a pre-multiplier should not affect the measurements, since it simply filters information which is not included in the support of the blur kernel. We can therefore add this to our forward model:\n",
    "\n",
    "$$A = W F^H diag(\\tilde{b}_i) F diag(M_i) $$\n",
    "\n",
    "Let's first consider the case without the additional $W$. This would provide a near perfect measurement, but would have some extra values outside the support of $W$:\n",
    "\n",
    "$$A^* = diag(\\tilde{b}_i) F diag(M_i) $$\n",
    "\n",
    "We know from previous numerical simulations that we cannot evaluate the condition number of two diagonal matricies seperated by a Fourier Transform; We can only bound it. However, we note here that the condition number of $A^H$ is the same as $A$. From this, we can derive two bounds, of the same form. This becomes most interesting when considering the multi-frame formulation. Let's consider a 3-measurement case without windowing:\n",
    "\n",
    "$$ A^{*} = \\begin{bmatrix}diag(\\tilde{b}_1) & 0 & 0 \\cr 0 & diag(\\tilde{b}_2) & 0 \\cr 0& 0 & diag(\\tilde{b}_3)\\end{bmatrix} \\begin{bmatrix}F & 0 & 0 \\cr 0 & F & 0 \\cr 0& 0 & F\\end{bmatrix} \\begin{bmatrix} diag(M_1) \\cr diag(M_2) \\cr diag(M_3)\\end{bmatrix}$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-25T17:55:22.350080Z",
     "start_time": "2018-01-25T17:55:20.395462Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Image size requires 1 x 3 images\n",
      "k_A1 is 11.60260773\n",
      "k_Bd is 51.55988693\n",
      "k_Mv is 1.41421354\n",
      "k_A2 is 11.60260963\n",
      "k_Bv is 7.05047226\n",
      "k_Md is inf\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/zfphil/anaconda3/lib/python3.6/site-packages/numpy/linalg/linalg.py:1487: RuntimeWarning: divide by zero encountered in true_divide\n",
      "  return s[..., 0]/s[..., -1]\n"
     ]
    },
    {
     "ename": "AssertionError",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mAssertionError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-31-3856df2f8620>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     57\u001b[0m \u001b[0;32massert\u001b[0m \u001b[0mk_A1\u001b[0m \u001b[0;34m<\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mk_Bv\u001b[0m \u001b[0;34m*\u001b[0m \u001b[0mk_Md\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     58\u001b[0m \u001b[0;32massert\u001b[0m \u001b[0mk_A1\u001b[0m \u001b[0;34m<\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mk_Bd\u001b[0m \u001b[0;34m*\u001b[0m \u001b[0mk_Mv\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 59\u001b[0;31m \u001b[0;32massert\u001b[0m \u001b[0mk_A1\u001b[0m \u001b[0;34m<\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mk_Bv\u001b[0m \u001b[0;34m*\u001b[0m \u001b[0mk_Mv\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;31mAssertionError\u001b[0m: "
     ]
    }
   ],
   "source": [
    "# Generate motion pathway\n",
    "point_list_full = blurkernel.genRasterMotionPathway(object_size, image_size, \n",
    "                                                         full_object_multi_pass=False)\n",
    "\n",
    "# Generate blur kernel list\n",
    "blur_kernel_list = []\n",
    "for point_list_frame in point_list_full:\n",
    "    blur_kernel_list.append(blurkernel.pointListToBlurKernel(object_size, point_list_frame, np.random.rand(len(point_list_frame))))\n",
    "\n",
    "# Generate Fourier transform Matricies\n",
    "# Fourier transform operator\n",
    "F = ops.FourierTransform(object_size)\n",
    "F_list = []\n",
    "for index in range(len(blur_kernel_list)):\n",
    "    F_list.append(F)\n",
    "F_d = ops.DiagStack(F_list)\n",
    "\n",
    "B_list = []\n",
    "for index in range(len(blur_kernel_list)):\n",
    "    B_list.append(ops.Diagonalize(Ft(blur_kernel_list[index])))\n",
    "\n",
    "# Generate B matricies\n",
    "B_v = ops.Vstack(B_list)\n",
    "B_d = ops.DiagStack(B_list)\n",
    "\n",
    "# Generate diagonal M matricies\n",
    "kernel_support_list, object_support_list = blurkernel.genConvolutionSupportList(blur_kernel_list, image_size)\n",
    "\n",
    "M_list = []\n",
    "for index in range(len(blur_kernel_list)):\n",
    "    M_list.append(ops.Diagonalize(object_support_list[index]))\n",
    "\n",
    "# Generate B matricies\n",
    "M_v = ops.Vstack(M_list)\n",
    "M_d = ops.DiagStack(M_list)\n",
    "\n",
    "# First case: condition number of B * F * M\n",
    "A1 = B_d * F_d * M_v\n",
    "k_A1 = np.linalg.cond(A1.asFullMatrix())\n",
    "k_Bd = np.linalg.cond(B_d.asFullMatrix())\n",
    "k_Mv = np.linalg.cond(M_v.asFullMatrix())\n",
    "\n",
    "print('k_A1 is %.8f' % k_A1)\n",
    "print('k_Bd is %.8f' % k_Bd)\n",
    "print('k_Mv is %.8f' % k_Mv)\n",
    "\n",
    "# Second case: condition number of M * F * B\n",
    "A2 = A1.H\n",
    "k_A2 = np.linalg.cond(A2.asFullMatrix())\n",
    "k_Bv = np.linalg.cond(B_v.asFullMatrix())\n",
    "k_Md = np.linalg.cond(M_d.asFullMatrix())\n",
    "\n",
    "print('k_A2 is %.8f' % k_A2)\n",
    "print('k_Bv is %.8f' % k_Bv)\n",
    "print('k_Md is %.8f' % k_Md)\n",
    "\n",
    "assert k_A1 <= (k_Bv * k_Md)\n",
    "assert k_A1 <= (k_Bd * k_Mv)\n",
    "assert k_A1 <= (k_Bv * k_Mv)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-23T19:55:24.174166Z",
     "start_time": "2018-01-23T19:55:23.418439Z"
    }
   },
   "outputs": [],
   "source": [
    "D1 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "D2 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "D_diag = ops.DiagStack((D1, D2))\n",
    "\n",
    "D3 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "D4 = ops.Diagonalize(np.random.rand(image_size[0], image_size[1]) + 1j * np.random.rand(image_size[0], image_size[1]), dtype=np.complex128)\n",
    "D_vert = ops.Vstack((D3, D4))\n",
    "\n",
    "F = ops.FourierTransform(image_size, dtype=np.complex128)\n",
    "F_diag = ops.DiagStack((F, F))\n",
    "\n",
    "A = D_diag * F_diag.H * D_vert\n",
    "\n",
    "# Calculate condition numbersaa\n",
    "k_D_diag = np.linalg.cond(D_diag.asFullMatrix())\n",
    "k_D_vert = np.linalg.cond((F_diag.H * D_vert).asFullMatrix())\n",
    "k_A = np.linalg.cond(A.asFullMatrix())\n",
    "\n",
    "# Analytic calculation of condition numbers:\n",
    "c = np.sqrt(np.abs(D1.mult * D3.mult) ** 2 + np.abs(D2.mult * D4.mult) ** 2)\n",
    "k_c = np.amax(c) / np.amin(c)\n",
    "\n",
    "print('k_D_diag: %.8f' % k_D_diag)\n",
    "print('k_D_vert: %.8f' % k_D_vert)\n",
    "print('k_A: %.8f' % k_A)\n",
    "print('k_c: %.8f' % k_c)\n",
    "assert np.abs(k_A - k_c) < 1e-10, \"Found difference of %.12f\" % abs(k_A - k_c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-23T19:58:55.971568Z",
     "start_time": "2018-01-23T19:58:55.934586Z"
    }
   },
   "outputs": [],
   "source": [
    "math.sqrt(k_D_diag ** 2 + k_D_vert ** 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-18T23:04:50.082782Z",
     "start_time": "2018-01-18T23:04:50.008094Z"
    }
   },
   "outputs": [],
   "source": [
    "n=len(blur_kernel_list)\n",
    "\n",
    "# Generate crop operators\n",
    "W = ops.Crop(object_size, image_size)\n",
    "W_list = []\n",
    "for index in range(n):\n",
    "    W_list.append(W)\n",
    "W_d = ops.DiagStack(W_list)\n",
    "\n",
    "# Generate shift operators\n",
    "shifts = image_size[1] * np.arange(-(n-1)/2, (n-1)/2+1)\n",
    "S_list = []\n",
    "for index in range(n):\n",
    "    S = ops.Shift(object_size, (0, shifts[index]))\n",
    "    S_list.append(S)\n",
    "S_d = ops.DiagStack(S_list)\n",
    "\n",
    "B_list = []\n",
    "for index in range(n):\n",
    "    B_list.append(ops.Diagonalize(Ft(blur_kernel_list[index])))\n",
    "\n",
    "# Diagonal stacked diagonal matricies\n",
    "B_v = ops.Vstack(B_list)\n",
    "B_d = ops.DiagStack(B_list)\n",
    "\n",
    "# Fourier transform operator\n",
    "F = ops.FourierTransform(object_size)\n",
    "F_list = []\n",
    "for index in range(n):\n",
    "    F_list.append(F)\n",
    "F_d = ops.DiagStack(F_list)\n",
    "\n",
    "# Full Forward Operator\n",
    "A = W_d * S_d * S_d.H * F_d.H * B_v"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-18T23:50:37.031924Z",
     "start_time": "2018-01-18T23:50:37.002344Z"
    }
   },
   "outputs": [],
   "source": [
    "b = np.asarray(blur_kernel_list)\n",
    "k_b = np.amax(np.abs(Ft(b))) / np.amin(np.abs(Ft(b)))\n",
    "print(k_b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2018-01-19T23:36:50.317629Z",
     "start_time": "2018-01-19T23:36:43.497954Z"
    }
   },
   "outputs": [],
   "source": [
    "A = S_d * S_d.H * F_d.H * B_v\n",
    "K_A = np.linalg.cond(A.asFullMatrix())\n",
    "K_B = np.linalg.cond((F_d.H * B_v).asFullMatrix())\n",
    "# K_Bd = np.linalg.cond((B_d).asFullMatrix())\n",
    "K_W = np.linalg.cond((W_d * S_d).asFullMatrix())\n",
    "print('K_A is %.6f' % K_A)\n",
    "print('K_B is %.6f' % K_B)\n",
    "# print('K_Bd is %.6f' % K_Bd)\n",
    "print('K_W is %.6f' % K_W)\n",
    "print(K_A / K_B)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [default]",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
